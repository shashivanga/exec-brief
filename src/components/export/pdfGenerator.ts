import jsPDF from 'jspdf';

interface PDFExportOptions {
  dashboardData: any[];
  companyName: string;
  reportTitle: string;
  includeBranding: boolean;
}

interface CardData {
  title: string;
  category: string;
  metrics: Array<{
    label: string;
    value: string;
    trend?: 'up' | 'down';
    change?: string;
  }>;
  timestamp: string;
}

export const generatePDF = async (options: PDFExportOptions) => {
  const { dashboardData, companyName, reportTitle, includeBranding } = options;
  
  // Create new PDF document
  const pdf = new jsPDF('portrait', 'mm', 'a4');
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const margin = 20;
  const contentWidth = pageWidth - (2 * margin);
  
  let currentY = margin;
  let pageNumber = 1;
  
  // Helper function to add a new page
  const addNewPage = () => {
    pdf.addPage();
    pageNumber++;
    currentY = margin;
    addPageHeader();
  };
  
  // Helper function to check if we need a new page
  const checkPageBreak = (requiredHeight: number) => {
    if (currentY + requiredHeight > pageHeight - margin - 20) { // Leave space for footer
      addNewPage();
    }
  };
  
  // Add page header
  const addPageHeader = () => {
    // Company branding
    if (includeBranding && companyName) {
      pdf.setFontSize(12);
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(70, 130, 240); // Primary blue
      pdf.text(companyName, margin, currentY);
      currentY += 8;
    }
    
    // Report title
    pdf.setFontSize(18);
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(0, 0, 0);
    pdf.text(reportTitle, margin, currentY);
    currentY += 10;
    
    // Date and time
    const now = new Date();
    const dateStr = now.toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
    const timeStr = now.toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      timeZoneName: 'short'
    });
    
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor(100, 100, 100);
    pdf.text(`Generated on ${dateStr} at ${timeStr}`, margin, currentY);
    currentY += 15;
    
    // Divider line
    pdf.setDrawColor(200, 200, 200);
    pdf.line(margin, currentY, pageWidth - margin, currentY);
    currentY += 15;
  };
  
  // Add page footer
  const addPageFooter = () => {
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor(150, 150, 150);
    
    // Page number
    const footerY = pageHeight - 10;
    pdf.text(`Page ${pageNumber}`, pageWidth - margin - 20, footerY);
    
    // Decks branding (small)
    if (includeBranding) {
      pdf.text('Generated by Decks Analytics Platform', margin, footerY);
    }
  };
  
  // Get category color
  const getCategoryColor = (category: string): [number, number, number] => {
    switch (category) {
      case 'competitor':
        return [220, 38, 38]; // Red
      case 'industry':
        return [37, 99, 235]; // Blue
      case 'company':
        return [22, 163, 74]; // Green
      case 'macro':
        return [147, 51, 234]; // Purple
      case 'briefing':
        return [70, 130, 240]; // Primary blue
      default:
        return [100, 100, 100]; // Gray
    }
  };
  
  // Draw a card
  const drawCard = (card: CardData, x: number, y: number, width: number, height: number) => {
    // Card background
    pdf.setFillColor(250, 250, 250);
    pdf.setDrawColor(230, 230, 230);
    pdf.roundedRect(x, y, width, height, 2, 2, 'FD');
    
    // Category color bar
    const [r, g, b] = getCategoryColor(card.category);
    pdf.setFillColor(r, g, b);
    pdf.roundedRect(x, y, width, 4, 2, 2, 'F');
    
    let cardY = y + 12;
    
    // Card title
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(0, 0, 0);
    const titleLines = pdf.splitTextToSize(card.title, width - 12);
    pdf.text(titleLines, x + 6, cardY);
    cardY += titleLines.length * 6 + 4;
    
    // Category badge
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor(r, g, b);
    pdf.text(card.category.toUpperCase(), x + 6, cardY);
    cardY += 8;
    
    // Metrics
    pdf.setFontSize(10);
    card.metrics.slice(0, 2).forEach((metric, index) => {
      // Metric label
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(100, 100, 100);
      pdf.text(metric.label, x + 6, cardY);
      cardY += 5;
      
      // Metric value
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(0, 0, 0);
      pdf.text(metric.value, x + 6, cardY);
      
      // Trend indicator
      if (metric.change && metric.trend) {
        const trendColor: [number, number, number] = metric.trend === 'up' ? [22, 163, 74] : [220, 38, 38];
        pdf.setFont('helvetica', 'normal');
        pdf.setTextColor(...trendColor);
        const arrow = metric.trend === 'up' ? '↗' : '↘';
        pdf.text(`${arrow} ${metric.change}`, x + width - 30, cardY);
      }
      
      cardY += 8;
    });
    
    // Timestamp
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor(150, 150, 150);
    pdf.text(`Updated ${card.timestamp}`, x + 6, y + height - 8);
  };
  
  // Start generating PDF
  addPageHeader();
  
  // Process dashboard cards
  const cardsPerPage = 4;
  const cardsPerRow = 2;
  const cardWidth = (contentWidth - 10) / 2; // 10mm gap between cards
  const cardHeight = 55;
  const cardSpacing = 15;
  
  let cardsOnCurrentPage = 0;
  
  dashboardData.forEach((card, index) => {
    // Check if we need a new page (every 4 cards)
    if (cardsOnCurrentPage >= cardsPerPage) {
      addPageFooter();
      addNewPage();
      cardsOnCurrentPage = 0;
    }
    
    // Calculate position
    const cardIndex = cardsOnCurrentPage;
    const row = Math.floor(cardIndex / cardsPerRow);
    const col = cardIndex % cardsPerRow;
    
    const x = margin + col * (cardWidth + 10);
    const y = currentY + row * (cardHeight + cardSpacing);
    
    // Check if card fits on current page
    checkPageBreak(cardHeight + cardSpacing);
    
    // Draw the card
    drawCard(card, x, y, cardWidth, cardHeight);
    
    cardsOnCurrentPage++;
    
    // Update currentY after placing 2 cards (one row)
    if (cardsOnCurrentPage % cardsPerRow === 0) {
      currentY += cardHeight + cardSpacing;
    }
  });
  
  // Add footer to last page
  addPageFooter();
  
  // Generate filename
  const timestamp = new Date().toISOString().split('T')[0];
  const filename = `${reportTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${timestamp}.pdf`;
  
  // Save the PDF
  pdf.save(filename);
};